{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red242\green242\blue242;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0\c54118;\cssrgb\c96078\c96078\c96078;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 In Kubernetes, we give commands to master node which can turn controls slave nodes\
\
Kubernetes is best suited in scenarios where scaling is not uniform, if application has 3 containers and we only want to scale the 2nd container\
\
Minikube can be used to setup Kubernetes cluster on a local machine, we could also use Colima\
\
Kubectl for managing the containers in Kubernetes clusters/nodes\
\
kubectl cluster-info, this tell vm address Minikube is pointing to\
\
Config files are passed to kubectl  to run containers within  a Kubernetes cluster\
\
Defining api version in config files gives access to set objects we can use\
\
minikube start \'97driver=qemu2, starting Kubernetes vm using qemu2\'92\
\
Generally in Kubernetes architecture, theree is a vm 0r node, within the vm there are multiple objects, such as Pod object which takes care of deploying container/instances\
\
Mostly a Pod contains group of container serving similar purpose or tightly coupled to each other\
\
One can\'92t run container inside a kuberenets cluster, it should be inside a Pod\
\
Kubeproxy is a program in Kubernetes cluster which is one single window to for network flow and routing\
\
kubctl get pods, this cmd will get status of all pods within k8 cluster \
\
Kubectl create -f filename, this creates an object in kubernetes cluster using specified filename\
\
kubectl apply -f filename, this cli cmd will change current config of Kubernetes container/object referring to a file\
\
The container created using kuberentes for a pod, essentially run in a vm, in our case docker environment\
\
Kubectl master nodes has 4 programs in total, monitors every slave node\
\
Generally when we went to host a container in a pod, what happens is that master nodes parses config files, sends command to slave nodes and each slave node has its own docker env and also Kubernetes vm has its dedicated docker. So it pulls image from registry, runs docker image, reports back to ma star node about completion. These slaves are within a pod.\
\
Kubectl if it finds a pod and name from config file matching to any object inside kubertes cluster then it is just going to update the container within it rather than creating new\
\
kubectl describe pod client-pod, this cmd will describe pod object type having object nam client-pod\
\
Deployment object type is used to ensure smooth upgrades, updating config easily of containers, and this can\'92t be done using pod object type\
\
kubectl set image objectType/objectName containerName=newImageName, this cmd is imperative way to update image of a given container for a given type of object and its name\
\
Cluster service does not provide way to access to outside traffic\
\
PVC-persistent volume claim, can be thought of as an advertisement to number of volume sizes/option available on local system\
\
In Kubernetes volume type obj creates persistent storage inside a pod so if container dies data can be retrieved but if pod dies data can not be retrieved\
\
kubectl get storageclass, this cmd shows all different storage options Kubernetes has\
\
kubectl describe storageclass, this cmd shows description of available storage classes\
\
kubectl create secret <type of secret> <name of secret> --from-literal key=value, this is used to create secret obj of a given type and name, from literal means it is going to take key value information right from cmd, generic secret type is used for docker containers\
\
Load balancer type service object is a legacy one. It allows access to one specific set of pods which is not the case generally. There maybe multiple sets. When creating load balancer, on cloud, it reaches to the provider and creates cloud balancer according to their specification. This is created outside node and from there traffic is routed from outside to inside load balancer. one external lb/internal lb\
\
Using ingress-nginx bypasses clusters ip service obj and directly connects to the pods, this gives feature like sticky session, I.e two requests made by a client to the a specific pod in pod set instead of load balanced\
\
Namespace is used to isolate different resources created inside container\
\
\pard\pardeftab720\partightenfactor0

\f1\fs30 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml, required before setting up ingress nginx, creates default required object\
\
}